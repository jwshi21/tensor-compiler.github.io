The scheduling language enables users to specify and compose transformations to further optimize the code generated by taco. 

Consider the following SpMV computation and associated code, which we will transform below:
```c++
Format csr({Dense,Sparse});
Tensor<double> A("A", {512, 64}, csr);
Tensor<double> x("x", {64}, {Dense});
Tensor<double> y("y", {512}, {Dense});

IndexVar i, j; 
y(i) = A(i, j) * x(j);
IndexStmt stmt = y.getAssignment().concretize();
```
```c
for (int32_t i = 0; i < A1_dimension; i++) {
	double y_val = 0.0;
	for (int32_t jA = A2_pos[i]; jA < A2_pos[(i + 1)]; jA++) {
		int32_t j = A2_crd[jA];
		y_val += A_vals[jA] * x_vals[j];
	}
	y_vals[i] = y_val;
}
```
# Pos

The `pos(i, ipos, access)` transformation takes in an index variable `i` that operates over the coordinate space of `access` and replaces it with a derived index variable `ipos` that operates over the same iteration range, but with respect to the the position space. 

Since the `pos` transformation is not valid for dense level formats, for the SpMV example, the following would result in an error:
```c++
stmt = stmt.pos(i, IndexVar("ipos"), A);
```

We could instead have: 
```c++
stmt = stmt.pos(j, IndexVar("jpos"), A);
```
```c
for (int32_t i = 0; i < A1_dimension; i++) {
    for (int32_t jposA = A2_pos[i]; jposA < A2_pos[(i + 1)]; jposA++) {
      	if (jposA < A2_pos[i] || jposA >= A2_pos[(i + 1)])
        	continue;

    	int32_t j = A2_crd[jposA];
    	y_vals[i] = y_vals[i] + A_vals[jposA] * x_vals[j];
    }
} 
```

# Split 

The `split(i, i0, i1, splitFactor)` transformation splits (strip-mines) an index variable `i` into two nested index variables `i0` and `i1`. The size of the inner index variable `i1` is then held constant at `splitFactor`, which must be a positive integer.

For the SpMV example, we could have: 
```c++
stmt = stmt.split(j, IndexVar("i0"), IndexVar("i1"), 16);
```
```c
for (int32_t i0 = 0; i0 < ((A1_dimension + 15) / 16); i0++) {
    for (int32_t i1 = 0; i1 < 16; i1++) {
      	int32_t i = i0 * 16 + i1;
      	if (i >= A1_dimension)
        	continue;

    	for (int32_t jA = A2_pos[i]; jA < A2_pos[(i + 1)]; jA++) {
        	int32_t j = A2_crd[jA];
        	y_vals[i] = y_vals[i] + A_vals[jA] * x_vals[j];
    	}
    }
}
```

# Reorder

The `reorder(vars)` transformation takes in a new ordering for a set of index variables in the expression that are directly nested in the iteration order. 

For the SpMV example, we could have: 
```c++
stmt = stmt.reorder({j, i});
```
```c
for (int32_t jA = A2_pos[iA]; jA < A2_pos[(iA + 1)]; jA++) {
    int32_t j = A2_crd[jA];
    for (int32_t i = 0; i < A1_dimension; i++) {
    	y_vals[i] = y_vals[i] + A_vals[jA] * x_vals[j];
    }
 }
```




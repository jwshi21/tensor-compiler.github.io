// Generated by the Tensor Algebra Compiler (tensor-compiler.org)
// taco "A(i,j)=B(i,j,k)*c(k)" -f=A:ss:0,1 -f=B:sss:0,1,2 -f=c:d:0 -s="fuse(i,j,f)" -s="pos(f,fpos,B)" -s="split(fpos,chunk,fpos2,8)" -s="reorder(chunk,fpos2,k)" -s="parallelize(chunk,CPUThread,NoRaces)" -write-source=taco_kernel.c -write-compute=taco_compute.c -write-assembly=taco_assembly.c

int compute(taco_tensor_t *A, taco_tensor_t *B, taco_tensor_t *c) {
  double* restrict A_vals = (double*)(A->vals);
  int B2_dimension = (int)(B->dimensions[1]);
  int* restrict B1_pos = (int*)(B->indices[0][0]);
  int* restrict B1_crd = (int*)(B->indices[0][1]);
  int* restrict B2_pos = (int*)(B->indices[1][0]);
  int* restrict B2_crd = (int*)(B->indices[1][1]);
  int* restrict B3_pos = (int*)(B->indices[2][0]);
  int* restrict B3_crd = (int*)(B->indices[2][1]);
  double* restrict B_vals = (double*)(B->vals);
  int c1_dimension = (int)(c->dimensions[0]);
  double* restrict c_vals = (double*)(c->vals);

  int32_t pB2_begin = 0;
  int32_t pB2_end = B1_pos[1];

  int32_t jA = 0;

  #pragma omp parallel for schedule(runtime)
  for (int32_t chunk = 0; chunk < ((B2_pos[B1_pos[1]] + 7) / 8); chunk++) {
    int32_t fposB = chunk * 8;
    int32_t i_pos = taco_binarySearchBefore(B2_pos, pB2_begin, pB2_end, fposB);
    int32_t i = B1_crd[i_pos];
    for (int32_t fpos2 = 0; fpos2 < 8; fpos2++) {
      int32_t fposB = chunk * 8 + fpos2;
      if (fposB >= B2_pos[B1_pos[1]])
        continue;

      int32_t f = B2_crd[fposB];
      if (fposB == B2_pos[(i_pos + 1)]) {
        i_pos++;
        i = B1_crd[i_pos];
      }
      A_vals[jA] = 0.0;
      for (int32_t kB = B3_pos[fposB]; kB < B3_pos[(fposB + 1)]; kB++) {
        int32_t k = B3_crd[kB];
        A_vals[jA] = A_vals[jA] + B_vals[kB] * c_vals[k];
      }
      jA++;
    }
  }
  return 0;
}

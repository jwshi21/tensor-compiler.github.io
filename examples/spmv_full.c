// Generated by the Tensor Algebra Compiler (tensor-compiler.org)
// taco "y(i)=A(i,j)*x(j)" -f=y:d:0 -f=A:ds:0,1 -f=x:d:0 -write-source=taco_kernel.c -write-compute=taco_compute.c -write-assembly=taco_assembly.c
#ifndef TACO_C_HEADERS
#define TACO_C_HEADERS
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#define TACO_MIN(_a,_b) ((_a) < (_b) ? (_a) : (_b))
#ifndef TACO_TENSOR_T_DEFINED
#define TACO_TENSOR_T_DEFINED
typedef enum { taco_dim_dense, taco_dim_sparse } taco_dim_t;
typedef struct {
  int32_t     order;      // tensor order (number of dimensions)
  int32_t*    dims;       // tensor dimensions
  taco_dim_t* dim_types;  // dimension storage types
  int32_t     csize;      // component size
  int32_t*    dim_order;  // dimension storage order
  uint8_t***  indices;    // tensor index data (per dimension)
  uint8_t*    vals;       // tensor values
} taco_tensor_t;
#endif
#endif

int assemble(taco_tensor_t *y, taco_tensor_t *A, taco_tensor_t *x) {
  int y0_size = *(int*)(y->indices[0][0]);
  double* restrict y_val_arr = (double*)(y->vals);

  y_val_arr = (double*)malloc(sizeof(double) * y0_size);

  y->vals = (uint8_t*)y_val_arr;
  return 0;
}

int compute(taco_tensor_t *y, taco_tensor_t *A, taco_tensor_t *x) {
  int y0_size = *(int*)(y->indices[0][0]);
  double* restrict y_val_arr = (double*)(y->vals);
  int A0_size = *(int*)(A->indices[0][0]);
  int* restrict A1_pos_arr = (int*)(A->indices[1][0]);
  int* restrict A1_idx_arr = (int*)(A->indices[1][1]);
  double* restrict A_val_arr = (double*)(A->vals);
  int x0_size = *(int*)(x->indices[0][0]);
  double* restrict x_val_arr = (double*)(x->vals);

  #pragma omp parallel for
  for (int32_t iA = 0; iA < A0_size; iA++) {
    double tj = 0;
    for (int32_t A1_pos = A1_pos_arr[iA]; A1_pos < A1_pos_arr[iA + 1]; A1_pos++) {
      int32_t jA = A1_idx_arr[A1_pos];
      tj += A_val_arr[A1_pos] * x_val_arr[jA];
    }
    y_val_arr[iA] = tj;
  }

  return 0;
}

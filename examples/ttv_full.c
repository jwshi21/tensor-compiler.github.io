// Generated by the Tensor Algebra Compiler (tensor-compiler.org)
// taco "A(i,j)=B(i,j,k)*c(k)" -f=A:ss:0,1 -f=B:sss:0,1,2 -f=c:d:0 -write-source=taco_kernel.c -write-compute=taco_compute.c -write-assembly=taco_assembly.c
#ifndef TACO_C_HEADERS
#define TACO_C_HEADERS
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#define TACO_MIN(_a,_b) ((_a) < (_b) ? (_a) : (_b))
#ifndef TACO_TENSOR_T_DEFINED
#define TACO_TENSOR_T_DEFINED
typedef enum { taco_dim_dense, taco_dim_sparse } taco_dim_t;
typedef struct {
  int32_t     order;      // tensor order (number of dimensions)
  int32_t*    dims;       // tensor dimensions
  taco_dim_t* dim_types;  // dimension storage types
  int32_t     csize;      // component size
  int32_t*    dim_order;  // dimension storage order
  uint8_t***  indices;    // tensor index data (per dimension)
  uint8_t*    vals;       // tensor values
} taco_tensor_t;
#endif
#endif

int assemble(taco_tensor_t *A, taco_tensor_t *B, taco_tensor_t *c) {
  int* restrict A1_pos = (int*)(A->indices[0][0]);
  int* restrict A1_idx = (int*)(A->indices[0][1]);
  int* restrict A2_pos = (int*)(A->indices[1][0]);
  int* restrict A2_idx = (int*)(A->indices[1][1]);
  double* restrict A_vals = (double*)(A->vals);
  int* restrict B1_pos = (int*)(B->indices[0][0]);
  int* restrict B1_idx = (int*)(B->indices[0][1]);
  int* restrict B2_pos = (int*)(B->indices[1][0]);
  int* restrict B2_idx = (int*)(B->indices[1][1]);
  int* restrict B3_pos = (int*)(B->indices[2][0]);
  int* restrict B3_idx = (int*)(B->indices[2][1]);
  int c1_size = *(int*)(c->indices[0][0]);

  /* init_alloc_size should be initialized to a power of two */
  int32_t init_alloc_size = 1048576;
  A1_pos = (int*)malloc(sizeof(int) * init_alloc_size);
  A1_idx = (int*)malloc(sizeof(int) * init_alloc_size);
  A1_pos[0] = 0;
  A2_pos = (int*)malloc(sizeof(int) * init_alloc_size);
  A2_idx = (int*)malloc(sizeof(int) * init_alloc_size);
  A2_pos[0] = 0;

  int32_t pA1 = A1_pos[0];
  int32_t pA2 = A2_pos[pA1];
  for (int32_t pB1 = B1_pos[0]; pB1 < B1_pos[1]; pB1++) {
    int32_t iB = B1_idx[pB1];
    for (int32_t pB2 = B2_pos[pB1]; pB2 < B2_pos[pB1 + 1]; pB2++) {
      int32_t jB = B2_idx[pB2];
      for (int32_t pB3 = B3_pos[pB2]; pB3 < B3_pos[pB2 + 1]; pB3++) {
        int32_t kB = B3_idx[pB3];

      }
      A2_idx[pA2] = jB;
      pA2++;
      if ((0 == ((pA2 + 1) & pA2)) && (init_alloc_size <= (pA2 + 1)))
        A2_idx = (int*)realloc(A2_idx, sizeof(int) * (2 * (pA2 + 1)));
    }
    A2_pos[(pA1 + 1)] = pA2;
    A1_idx[pA1] = iB;
    if (A2_pos[pA1 + 1] > A2_pos[pA1]) {
      pA1++;
      if ((0 == ((pA1 + 1) & pA1)) && (init_alloc_size <= (pA1 + 1))) {
        A1_idx = (int*)realloc(A1_idx, sizeof(int) * (2 * (pA1 + 1)));
        A2_pos = (int*)realloc(A2_pos, sizeof(int) * (2 * (pA1 + 1)));
      }
    }
  }
  A1_pos[1] = pA1;

  A_vals = (double*)malloc(sizeof(double) * pA2);

  A->indices[0][0] = (uint8_t*)(A1_pos);
  A->indices[0][1] = (uint8_t*)(A1_idx);
  A->indices[1][0] = (uint8_t*)(A2_pos);
  A->indices[1][1] = (uint8_t*)(A2_idx);
  A->vals = (uint8_t*)A_vals;
  return 0;
}

int compute(taco_tensor_t *A, taco_tensor_t *B, taco_tensor_t *c) {
  int* restrict A1_pos = (int*)(A->indices[0][0]);
  int* restrict A2_pos = (int*)(A->indices[1][0]);
  double* restrict A_vals = (double*)(A->vals);
  int* restrict B1_pos = (int*)(B->indices[0][0]);
  int* restrict B1_idx = (int*)(B->indices[0][1]);
  int* restrict B2_pos = (int*)(B->indices[1][0]);
  int* restrict B2_idx = (int*)(B->indices[1][1]);
  int* restrict B3_pos = (int*)(B->indices[2][0]);
  int* restrict B3_idx = (int*)(B->indices[2][1]);
  double* restrict B_vals = (double*)(B->vals);
  int c1_size = *(int*)(c->indices[0][0]);
  double* restrict c_vals = (double*)(c->vals);

  int32_t pA1 = A1_pos[0];
  int32_t pA2 = A2_pos[pA1];
  for (int32_t pB1 = B1_pos[0]; pB1 < B1_pos[1]; pB1++) {
    int32_t iB = B1_idx[pB1];
    for (int32_t pB2 = B2_pos[pB1]; pB2 < B2_pos[pB1 + 1]; pB2++) {
      int32_t jB = B2_idx[pB2];
      double tk = 0;
      for (int32_t pB3 = B3_pos[pB2]; pB3 < B3_pos[pB2 + 1]; pB3++) {
        int32_t kB = B3_idx[pB3];
        tk += B_vals[pB3] * c_vals[kB];
      }
      A_vals[pA2] = tk;
      pA2++;
    }
    if (A2_pos[pA1 + 1] > A2_pos[pA1]) pA1++;
  }

  return 0;
}
